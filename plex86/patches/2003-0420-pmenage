From:"Paul Menage" <pmenage@ensim.com>
To:plex86-developers@lists.sourceforge.net
CC:pmenage@ensim.com
Subject: [Plex86-developers] [PATCH] Handle software interrupts within 16 bytes of a page end
Date: Sun, 20 Apr 2003 23:26:41 -0700

With the patch below, I can successfully boot an NFS-mounted fairly
minimal RedHat 7.3 filesystem (130 RPMs, about 190MB total filesystem
size). I can log in to the guest via ssh, and ssh back into the host
from there.

In order to boot, I had to chmod -x /sbin/hwclock, otherwise plex86
bombed out due to IOPL being non-zero; apart from that, everything went
pretty smoothly.

Without the patch, the system gets stuck when it encounters an int 80
instruction in the last 16 bytes of a page. Since we're currently only 
interested in emulating int XX instructions, the patch changes it to 
use getGuestWord() to retrieve the opcode. (Also, getGuestWord() is 
extended to support retrieving words that cross page boundaries).

Longer term, perhaps some software interrupts (particularly int 80 since
we're interested in Linux) could be made unprivileged, with special
handling routines in the monitor. (Is anyone working on moving
doInterrupt() into monitor space?)

Paul

Index: host-user/x86-emu.c
===================================================================
RCS file: /cvsroot/plex86/plex86/host-user/x86-emu.c,v
retrieving revision 1.1
diff -u -r1.1 x86-emu.c
--- host-user/x86-emu.c 17 Feb 2003 03:50:27 -0000  1.1
+++ host-user/x86-emu.c 21 Apr 2003 06:19:19 -0000
@@ -94,6 +94,7 @@
 static unsigned  loadGuestSegment(unsigned sreg, unsigned selector);
 static Bit32u    getGuestDWord(Bit32u lAddr);
 static Bit16u    getGuestWord(Bit32u lAddr);
+static Bit8u     getGuestByte(Bit32u lAddr);
 static void      writeGuestDWord(Bit32u lAddr, Bit32u val);
 static descriptor_t *fetchGuestDescriptor(selector_t);
 static unsigned  inp(unsigned iolen, unsigned port);
@@ -772,10 +773,12 @@
   unsigned
 emulateUserInstr(void)
 {
-  phyAddr_t pAddr;
+
+  /* For now, the instruction fetch part of this function only handles
+     two-byte opcodes */
+
   unsigned b0, iLen=0;
-  Bit8u    opcode[16];
-  Bit32u  *opcodeDWords;
+  Bit8u    opcode[2];
   // modRM_t  modRM;
   // unsigned opsize = 1; // 32-bit opsize by default.
   Bit32u   lAddr;
@@ -785,31 +788,8 @@
     goto error;
     }
   lAddr = plex86GuestCPU->eip; // Forget segmentation base for Linux.
-  pAddr = translateLinToPhy(lAddr);
-  if (pAddr == -1) {
-    fprintf(stderr, "emulateUserInstr: lin-->phy translation failed (0x%x).\n",
-            lAddr);
-    return 0; // Fail.
-    }
-  if ( pAddr >= (plex86MemSize-16) ) {
-    fprintf(stderr, "emulateUserInstr: physical address of 0x%x "
-            "beyond memory.\n", pAddr);
-    return 0; // Fail.
-    }
-  if ( (pAddr&0xfff) <= 0xff0 ) {
-    // Draw in 16 bytes from guest memory.  No boundary checks are
-    // necessary since paging is off and we can't be overrunning
-    // the physical memory bounds.
-    opcodeDWords = (Bit32u*) &opcode[0];
-    opcodeDWords[0] = * (Bit32u*) &plex86MemPtr[pAddr+ 0];
-    opcodeDWords[1] = * (Bit32u*) &plex86MemPtr[pAddr+ 4];
-    opcodeDWords[2] = * (Bit32u*) &plex86MemPtr[pAddr+ 8];
-    opcodeDWords[3] = * (Bit32u*) &plex86MemPtr[pAddr+12];
-    }
-  else {
-    fprintf(stderr, "emulateUserInstr: possible page crossing.\n");
-    return 0; // Fail.
-    }
+
+  *(Bit16u *)opcode = getGuestWord(lAddr);
 
 // decodeOpcode:
 
@@ -1110,14 +1090,39 @@
     goto error;
     }
   if ( (pAddr & 0xfff) >= 0xfff ) {
-    fprintf(stderr, "getGuestWord: crosses page boundary.\n");
-    goto error;
+    Bit8u bytes[2];
+    bytes[0] = plex86MemPtr[pAddr];
+    bytes[1] = getGuestByte(lAddr + 1);
+    return ( *(Bit16u*) bytes);
     }
   return( * (Bit16u*) &plex86MemPtr[pAddr] );
 
 error:
   plex86TearDown(); exit(1);
 }
+
+Bit8u
+getGuestByte(Bit32u lAddr) 
+{
+  phyAddr_t pAddr;
+
+  pAddr = translateLinToPhy(lAddr);
+  
+  if (pAddr == -1) {
+    fprintf(stderr, "getGuestWord: could not translate address.\n");
+    goto error;
+    }
+  if ( pAddr >= (plex86MemSize) ) {
+    fprintf(stderr, "getGuestWord: phy address OOB.\n");
+    goto error;
+    }
+  return(plex86MemPtr[pAddr]);
+
+error:
+  plex86TearDown(); exit(1);
+ 
+}
+
 
   void
 writeGuestDWord(Bit32u lAddr, Bit32u val)
